With regards to the design of our final project, the key functionality of our website was to make a more conveniently selective course filtering system. We figured that we would be working quite a bit with databases, so we initially used "Finance" as the springboard/basis for beginning our implementation.

With application.py, we started off with a great deal of the HTML pages from finance. After "bootstrapping" our website to look the way we wanted it to, we worked to add the applicable pages that we wanted (profile.html, courses.html, etc.). After doing this, we proceeded to get rid of the superfluous elements from finance (buy.html, sell.html, etc.). Having the essential barebones that we needed, we worked on establishing valid routes and ensuring we could navigate the website generally without getting bombarded with internal server errors. Following this, application.py was to be fleshed out.

We started with the /index route. With index, there are two methods that it can be accessed by: GET requests or POST requests. If it is a GET request, we start off with a SQL selection command to get the name of the current user that's logged in and take their first name to be displayed on their personal information page (for sake of personalization). Then we selected all of the current times of courses in the database and removed repeats by iterating over each course element and allocating said information to a set. Else, if it’s a POST request, our code will be essentially correspondent to the Advanced Course Search feature. Then we would get all of the information from the various fields of the form (i.e. department, time of day, overall rating, instructor rating, and average hourly workload per week), using SQL selection commands to filter through each of these elements, then finding the similarities between all of these lists and allocating that data to a resultant list. This result is what the user see in terms of the displayed courses; this is basically each element in the database that satisfies each constraint necessary to give the user a course that satisfies their conditional entry.

The application.py file also has routes called /quicksearch (which performs a keyword search based on existing course titles), /course (which displays the full extent of information stored for a particular course wherever it is selected on this site), /courses (which presents a full page list of all the current courses available), /interest (which either adds or a removes a user from the list of interested students for a particular course), /comment (which adds a user’s comment to the list of comments for a particular course), /profile (which displays a user’s personalized profile), /login, /logout, and /register.

Each of the HTML files within our project uses some amount of Jijna to make them dynamic and personalized. Jinja is used, for example, on the homepage to provide a personalized “Welcome (first name)” message and on the profile page to display all of the current user’s information. It is also used heavily on the courses list and individual course page, so that we are not forced to create a different HTML file for each and every course in our database (~100 courses, currently). SQL selections along with passing the information through to the HTML files using Jinja contributed greatly to making the site look, feel, and operate like a real course catalog.

The two SQL tables within our yourharvard.db database are a users table and a courses table. The users table contains basic information about each user such as an ID number (primary key), their username/email, hashed password, name, house, concentration, class year, and bio. Much thought went into the field types for these elements of the users table structure, such as setting the varchar(#) values for name, house, and concentration based on the longest possibilities for each (with some extra room just in case). The purpose of these intentional design decisions is to save space and make our database as efficient as possible. The courses table has even more fields, including the course ID (primary key), title, instructor, date & time, description, department, general education fulfillments, divisional distribution fulfillments, course overall rating, instructor rating, weekly workload, a common identifier integer, interest indicated in the course, comments on the course, and the courses term. Again, each of the types of these fields was chosen very intentionally and with the space needed for each and use of each in mind. Elements like the title, description, general education and divisional distribution requirements, interest in the course, and comments on the course were chosen to be a “text” type due to how long their strings could become. Varchar(#) fields were also used for fields such as the course ID, instructor, date & time, department, and term were also used as a result of the maximum length we reasonably thought these fields could become (with some extra room just in case). Numeric types were used for the course rating fields (overall, instructor rating, and weekly workload). The common identifier integer is a smallint always set to 1, and is used in cases where we want to select all courses.

In addition to the aforementioned process used to find courses that fit the user’s filters in the Advanced Course Search tool, another challenging part of the design process was storing and displaying interest in courses and user comments on courses. Comments in particular are stored as an element of each course in the database with a “secret” delineator sequence of characters (“|@~”) which separates comments as they are stored and allows us to store them together but display them separately. For both the comments and the interest, a decent amount of string deconstruction and string rebuilding takes place to switch the display from being “No Comments” or “No students” to the list of students interested in the course, and back again if students previously interested in the course remove themselves.
